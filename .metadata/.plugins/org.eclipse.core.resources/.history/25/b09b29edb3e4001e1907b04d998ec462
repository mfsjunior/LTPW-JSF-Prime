Leia-me 
Vamos lá!
Informação importante para começar:

Faça o download do projeto que eu vou passar para vocês dois;
Descompacte o projeto no workspace (é a pasta onde estão todos os seus projetos java) do Eclipse;
Localize no menu do Eclipse a opção File / Import... / Maven / Existing Maven Projects;
Selecione o workspace que contém o projeto descompactado;
Com a pasta raiz do projeto selecionada (intro-spring-jpa), clique em OK e em seguida em Finish;
Aguarde alguns instantes que o projeto estará disponível.



Qual é o motivo para aguardar alguns instantes? Como expliquei em sala, utilizando o MAVEN temos a opção de colocar no arquivo da estrutura do projeto chamado POM todas as dependências que vamos utilizar. 


Falando sobre o nossa estrutura de projeto, temos o seguinte resumo:

br.com.curso.config: Pacote que contém as classes de configuração dos recursos do Spring. Neste pacote será incluída a classe de configuração que integra ao Spring o Hibernate e a JPA;

br.com.curso.dao: Pacote que armazena as classes referentes à persistência de dados baseada no padrão Data Access Object;

br.com.curso.domain: Aqui temos a classe de domínio (modelo) da aplicação, a qual recebe o mapeamento objeto relacional por anotações da JPA;

br.com.curso.web.controller: Neste pacote vamos adicionar as classes que representam os controllers no padrão MVC;

br.com.curso.web.conversor: Aqui estão as classes para realizar a conversão de tipos de dados entre recursos utilizados na view e no controller;

src/main/resources: Neste diretório adicionamos o arquivo de propriedades que contém as mensagens de validação do Bean Validation;

/webapp/WEB-INF/resources: É nesta pasta que adicionamos os arquivos estáticos, como CSS, JS ou imagens;

/webapp/WEB-INF/views: Como o nome indica, é nesta pasta que adicionamos as páginas web da aplicação, páginas de interação com os usuários;

pom.xml: Este arquivo contém as configurações do Maven para gerenciamento das dependências e build.

Atualizando as dependências do projeto

Vamos usar o Maven para gerenciamento das dependências e build. 
As informações referentes a essas funcionalidades são adicionadas no arquivo pom.xml.

Desta forma a explicação de cada elemento segue abaixo:
	
No código a seguir, apresentamos as dependências referentes ao Spring:

spring-context: Dependência responsável por fornecer os recursos referentes ao contexto do Spring Framework. A declaração do Spring Context também vai incluir no projeto outras bibliotecas do Spring, como o Spring Core, Spring Beans, entre outras;
spring-webmvc: Dependência responsável por incluir no projeto os recursos do Spring Web e Spring MVC;
spring-orm: Dependência responsável por fornecer os mecanismos de integração entre o Spring e frameworks ORM como o Hibernate e também a especificação JPA.

<dependency>
   <groupId>org.springframework</groupId>
   <artifactId>spring-context</artifactId>
   <version>4.3.8.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>4.3.8.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-orm</artifactId>
    <version>4.3.8.RELEASE</version>
</dependency>

Além disso, o projeto abordado no curso também vai utilizar JSTL junto a JSP nas páginas web e Hibernate Validator para a validação de formulários. Para fazer uso delas, mais algumas dependências são necessárias:

javax.servlet-api: Responsável por incluir na aplicação os recursos de Servlets, necessário para uso do Spring MVC;
jstl: Dependência que fornece os recursos da biblioteca JSTL;
javax.servlet.jsp-api: Biblioteca responsável por adicionar na aplicação os recursos ligados a JavaServer Pages;
hibernate-validator: Biblioteca que fornece os recursos necessários para a validação de formulários no lado servidor - baseada em bean validation.
<dependency>
   <groupId>javax.servlet</groupId>
   <artifactId>javax.servlet-api</artifactId>
   <version>3.1.0</version>
</dependency>
<dependency>
   <groupId>javax.servlet</groupId>
   <artifactId>jstl</artifactId>
   <version>1.2</version>
</dependency>
<dependency>
    <groupId>javax.servlet.jsp</groupId>
    <artifactId>javax.servlet.jsp-api</artifactId>
    <version>2.3.1</version>
</dependency>
<dependency>
     <groupId>org.hibernate</groupId>
     <artifactId>Hibernate-validator</artifactId>
     <version>5.3.2.Final</version>
</dependency>


Na parte de persistência devemos adicionar duas dependências, uma referente ao Hibernate e outra ao banco de dados que será utilizado:

hibernate-entitymanager: Responsável pelas bibliotecas necessárias para o uso do Hibernate ORM e da especificação JPA;
mysql-connector-java: Dependência responsável pelo driver de conexão do MySQL ( isso aqui pode mudar conforme o tipo de banco que a gente for utilizar).
<dependency>
   <groupId>org.hibernate</groupId>
   <artifactId>hibernate-entitymanager</artifactId>
   <version>5.2.8.Final</version>
</dependency>
<dependency>
   <groupId>mysql</groupId>
   <artifactId>mysql-connector-java</artifactId>
   <version>5.1.40</version>
   <scope>runtime</scope>
</dependency>


Além das dependências apresentadas, vamos utilizar o Maven para gerenciar o servidor Tomcat. Desta forma, não será necessário fazer o download, instalar e configurar na IDE o servidor. O próprio Maven se encarregará dessas ações. Para isso, incluímos na tag de build/plugins do pom.xml a seguinte configuração:

groupId: Indica ao Maven o grupo de dependências referentes ao Tomcat (simula o servidor web) no qual ele vai localizar a dependência indicada na tag artifactId;
artifactId: Informa o nome da dependência do Tomcat referente ao grupo indicado;
version: Versão da dependência do Tomcat;
port: Porta em que o Tomcat vai rodar. Este valor pode ser alterado para, por exemplo, 8080, 8090, 9080, ou qualquer outro;
path: Aqui é configurado o nome dado ao contexto da aplicação. Neste caso, a instrução captura o nome da tag finalName e a URL base da aplicação será: http://localhost:9090/intro-spring-jpa.
build>
   <finalName>intro-spring-jpa</finalName>
   <plugins>
      <plugin>
         <groupId>org.apache.tomcat.maven</groupId>
             <artifactId>tomcat7-maven-plugin</artifactId>
             <version>2.2</version>
             <configuration>
             <port>9090</port>
        <path>/${project.build.finalName}</path>
          </configuration>
       </plugin>
   </plugins>
</build>

Esse é o resumo básico da estrutura do nosso sistema. Acima eu falo o que estou utilizando e pq estou utilizando. Os recursos podem mudar conforme o tipo de projeto. 



-----**************************

configurando o Spring MVC ( Arquivo Spring Init Config ) 
A configuração de frameworks é uma etapa que pode levantar muitas dúvidas. O Spring MVC, assim como os demais, requer algumas configurações. Veja! ele não vai deixar vc livre para escolher, terá que seguir as normas que eles colocarem.  
Conheça, então, os passos iniciais para a configuração básica do Spring MVC junto ao Spring Framework. 
Essa configuração será totalmente baseada em código Java e será dividida em três classes principais.

Quando trabalhamos com o Spring MVC é necessário definir qual o tipo de recurso será usado nas páginas web (JSP, JSTL, Thymeleaf, etc.). 
Então, para informar o recurso escolhido devemos configurar um bean com essa informação. No caso, para uso de JSP com JSTL o bean a ser utilizado é o InternalResourceViewResolver, como descrito a seguir:

01 @Bean
02 public InternalResourceViewResolver viewResolver() {
03   InternalResourceViewResolver resolver = new InternalResourceViewResolver();
04   resolver.setPrefix("/WEB-INF/views/");
05   resolver.setSuffix(".jsp");
06   resolver.setViewClass(JstlView.class);
07   return resolver;
08 }

Linha 01: Define o método como um bean gerenciado pelo Spring Framework;

Linha 03: A instância da classe InternalResourceViewResolver é necessária para a configuração do view template do Spring MVC baseado em JSTL;

Linha 04: Configuração do prefixo da páginas JSPs. Assim, o Spring MVC sabe onde encontrar as páginas e não se faz necessário digitar esse caminho sempre que for necessário acessar uma dessas páginas;

Linha 05: Define o tipo de arquivo das páginas web. Assim, não se faz necessário digitar a extensão do arquivo sempre que se quiser acessar um desses arquivos através dos controllers;

Linha 06: A classe JstlView informa ao Spring MVC que o view template será baseado no framework JSTL.


Mapeando a classe de entidade

Para persistir dados a partir da especificação JPA é necessário realizar um processo denominado mapeamento objeto relacional. Este processo consiste em relacionar, por meio de anotações ou arquivos XML, as tabelas e colunas do banco de dados com as classes de domínio e seus atributos.

Neste projeto vamos mapear, por meio de anotações, a classe Usuario. Um exemplo desse mapeamento pode ser observado no código-fonte a seguir:

01 @Entity
02 @Table(name = "usuarios")
03 public class Usuario implements Serializable {
04
05     @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
06     private Long id;
07
08     @Column(nullable = false, length = 50)
09     private String nome;
10
11     @Column(nullable = false, length = 50)
12     private String sobrenome;
13
14     @Column(name = "data_nascimento", nullable = false)
15     private LocalDate dtNascimento;
16
17     @Column(name = "tipo_sexo", nullable = false)
18     @Enumerated(EnumType.STRING)
19     private TipoSexo sexo;
20
21     // demais métodos omitidos
22 }

Veja a seguir a finalidade das anotações utilizadas neste mapeamento:

@Entity: Usada sobre a assinatura da classe para marcá-la perante o Hibernate/JPA que esta é uma classe de mapeamento objeto relacional;
@Table: Informa ao Hibernate/JPA que a tabela que está sendo mapeada é aquela com o nome descrito na propriedade name da anotação;
@Id: Usada para mapear a coluna referente à chave primária da tabela. Esta anotação é obrigatória no mapeamento. Caso não seja adicionada uma exceção será lançada em tempo de execução;
@GeneratedValue: É utilizada para informar que a geração da chave primária da entidade será gerenciada pelo Hibernate e deve ser adicionada junto a anotação @Id. Quando não anotamos o campo com essa opção, significa que a responsabilidade de gerar e gerenciar as chaves primárias serão da aplicação;
@Column: Seu uso tem como finalidade mapear uma coluna da tabela. Se essa anotação não for declarada, o nome do atributo deverá ter o mesmo nome da coluna. Essa anotação possui alguns atributos para definir, por exemplo, se a coluna aceita valores nulos ou não (nullable), o tamanho de uma coluna varchar (length), entre outros;
@Enumerated: Usada para mapear uma coluna a partir de um atributo do tipo enum. Assim, podemos indicar se gravaremos esse dado de forma ordinal, a partir da posição do tipo declarado no enum, ou pelo seu nome.


CRIANDO A ENTIDADE (modelo de dados do meu usuário) 


Basicamente uma aplicação é construída em torno de uma ou mais classes de domínio (negócio), que é a representação de uma entidade de negócio. Por exemplo, para representar uma entidade de usuário, temos a classe Usuario, como descrita a seguir:

public class Usuario {

  private Long id; //atributos da entidade - são características que o objeto possue
  private String nome;
  private String sobrenome;

  public Usuario() {//contrutor (carrega tudo antes da execução da classe)
     super();//aqui estou chamando o construtor da classe que estou herdando
  }

   public Usuario(Long id, String nome, String sobrenome) {
     super();
     this.id = id;
     this.nome = nome;
     this.sobrenome = sobrenome;
   }
   // métodos getters/setters e toString()
}
Note que o código dessa classe é bastante simples.
Ele é composto por alguns atributos, dois construtores, os getters e setters e o método toString().



APRESENTANDO O DAO


Para simular o armazenamento de dados e assim poder focar nos recursos do Spring MVC, vamos criar um DAO, padrão de acesso a dados que, em nosso exemplo, vai abstrair o acesso a dados em memória. Esse DAO é constituído pela interface UsuarioDao, a qual será implementada pela classe concreta UsuarioDaoImpl.

Uma forma rápida de simular uma base de dados em uma aplicação é utilizando uma lista estática para o armazenamento dos registros. 
Desta forma, é possível inicializar a lista com alguns dados e ainda incluir, remover ou alterar os registros durante a execução da aplicação. 
Um exemplo pode ser visto a seguir:

private static List<Usuario> us;

private List<Usuario> createUserList() {
   if (us == null) {
     us = new LinkedList<>();
     us.add(new Usuario(System.currentTimeMillis()+1L, "Ana", "da Silva"));
     us.add(new Usuario(System.currentTimeMillis()+2L, "Luiz", "dos Santos"));
     us.add(new Usuario(System.currentTimeMillis()+3L, "Mariana", "Mello"));
     us.add(new Usuario(System.currentTimeMillis()+4L, "Caren", "Pereira"));
     us.add(new Usuario(System.currentTimeMillis()+5L, "Sonia", "Fagundes"));
     us.add(new Usuario(System.currentTimeMillis()+6L, "Norberto", "de Souza"));
   }
   return us;
}
Para interagir com a lista e simular as operações de um CRUD, vamos utilizar os recursos do Java 8. 
Como exemplo, vejamos o código do método excluir(), apresentado a seguir:

@Override
public void excluir(Long id) {
    us.removeIf((u) -> u.getId().equals(id));
}
O método removeIf() recebe como parâmetro uma expressão lambda para localizar na lista o objeto Usuario que deve ser removido. 
Esse usuário será encontrado a partir do atributo id. Em seguida, o objeto é excluído.



CRIANDO A TELA DE LISTAGEM 

A implementação da listagem de dados normalmente é a primeira funcionalidade a ser implementada de um CRUD. 
Você aprenderá aqui a desenvolver a página JSP responsável por exibir a lista de usuários cadastrados na aplicação. 
Essa lista será exibida em uma tabela com recursos de JSTL.
Para listar os dados armazenados em uma aplicação, comumente são usadas tabelas nas páginas web. 
Essas tabelas são baseadas em código HTML para definir suas estruturas como o cabeçalho (colunas) e o corpo (linhas). 
E para que os registros sejam exibidos na tabela, podemos usar o componente foreach da biblioteca JSTL, como apresentado a seguir:

01<table class="table table-striped table-condensed">
02   <thead>
03    <tr>
04     <th>ID</th>
05     <th>NOME</th>
06     <th>AÇÃO</th>
07    </tr>
08   </thead>
09   <tbody>
10     <c:forEach var="usuario" items="${usuarios }">
11      <tr>
12       <td>${usuario.id }</td>
13       <td>${usuario.nome } ${usuario.sobrenome }</td>
14       <td>
15        <a class="btn btn-info" href="#" >Editar</a>
16        <a class="btn btn-danger" href="#" >Excluir</a>
17       </td>
17      </tr>
18     </c:forEach>
19    </tbody>
20 </table>


Entre as Linhas 10 e 18 temos o processo que lista os usuários na tabela com auxílio da biblioteca JSTL:

Linha 10: A taglib core da JSTL utiliza o recurso foreach para a listar os dados. Esse recurso tem duas propriedades: 
items, que contém o objeto enviado pelo controller com a lista de usuários; e a propriedade var, que é o nome da variável que vai armazenar o objeto usuario da posição atual no loop da lista;

Linha 12: Imprime na tabela o id do usuário na posição atual do loop;

Linha 13: Imprime na tabela o nome e sobrenome do usuário na posição atual do loop;

Linha 18: Fechamento da tag do processo foreach.


LISTANDO OS REGISTROS EM UMA TABELA

Aprenda como preparar um controller que vai enviar para uma página JSP um objeto contendo uma lista de registros, para que essa lista seja exibida na página de listagem dentro de uma tabela.
No Spring MVC a classe que representa um controller possui algumas particularidades que são importantes para os componentes View e Controller se comunicar. 
Além disso, essa classe será gerenciada pelo Spring Framework, fazendo uso dos recursos de injeção de dependências. 
Veja a seguir um breve exemplo da classe UsuarioController.

01 @Controller
02 @RequestMapping("usuario")
03 public class UsuarioController {
04    @Autowired
05     private UsuarioDao dao;
06
07     @RequestMapping(value = "/todos", method = RequestMethod.GET)
08     public ModelAndView listaTodos(ModelMap model) {
09    	 model.addAttribute("usuarios", dao.getTodos());
10   	 return new ModelAndView("/user/list", model);
11     }
12 }

Os principais pontos da classe UsuarioController são analisados a seguir:

Linha 01: Anotação responsável por transformar a classe em um bean do tipo controller;

Linha 02: Esta anotação mapeia o controller com o path usuario;

Linha 04: Anotação para injeção da dependência UsuarioDao;

Linha 07: Esta anotação vai definir o path para acesso ao método listaTodos() e também define este método como do tipo GET;

Linha 08: O argumento ModelMap é utilizado para armazenar os dados que serão enviados à página JSP;

Linha 09: O método addAttribute() recebe a variável que vai armazenar a lista de usuarios que será enviada para a página JSP;

Linha 10: A instância de ModelViewController retorna um objeto contendo a página JSP a ser exibida ao usuário e o objeto model com os dados enviados para a página.


CRIANDO TELA DE CADASTRO E EDIÇÃO 

Uma tela presente em qualquer aplicação é a de cadastro/edição dos dados referentes às classes de domínio. 
Assim, você aprenderá agora a criar uma nova página JSP que vai conter o formulário para as ações de cadastro e atualização dos registros armazenados na aplicação. 
Este formulário vai ser desenvolvido com recursos nativos do Spring MVC.
Para cadastrar ou alterar dados em uma aplicação web utilizamos um formulário HTML. No Spring MVC há um formulário próprio para esse tipo de ação e ele se difere do formulário HTML padrão devido alguns detalhes, como pode ser visto a seguir:

01  <form:form modelAttribute="usuario" action="${save }" method="post">
02   <div class="form-group">
03     <label for="nome">Nome: </label>
04     <form:input path="nome" class="form-control"/>
05   </div>
06   <div class="form-group">
07     <label for="sobrenome">Sobrenome: </label>
08     <form:input path="sobrenome"  class="form-control"/>
09   </div>
11   <div class="form-group">
11     <button type="submit" class="btn btn-primary">Confirmar</button>
12   </div>
13  </form:form>

Neste formulário temos alguns recursos nativos do Spring MVC, que são:

Linha 01: A tag <form:form> cria um formulário baseado em recursos do Spring, como é o caso do atributo modelAttribute, que realiza o bind entre objeto modelo (usuario), a view e o controller;

Linhas 04 e 08: A tag <form:input> representa um componente do tipo input que automaticamente identifica e faz o bind entre o atributo adicionado no atributo path e o objeto de domínio declarado em modelAttribute.


_CADASTRANDO NOVOS REGISTROS 

Para completar a tela de cadastro, é necessário adicionar ao respectivo controller o método que recebe os dados enviados de um formulário a partir do front-end da aplicação para realizar a operação de inserção via DAO.

Quando trabalhamos com Servlet, sem o auxílio de um framework MVC como o Spring, os dados enviados pelo formulário chegam ao lado servidor da aplicação em um objeto do tipo Request. Assim, devemos capturar do objeto Request os valores do formulário para depois atribuí-los a um objeto de domínio. Já no Spring MVC esse trabalho é minimizado. Os dados enviados via formulário para o controller já chegam no back-end no formato de um objeto de domínio, como pode ser visto a seguir:

01 @PostMapping("/save")
02 public String save(@ModelAttribute("usuario") Usuario usuario, RedirectAttributes attr) {
03   dao.salvar(usuario);
04   attr.addFlashAttribute("message", "Usuário salvo com sucesso.");
05   return "redirect:/usuario/todos";
06 }
Linha 01: Esta anotação é exclusiva para operações via POST e deve conter como parâmetro o path referente à solicitação do lado cliente;

Linha 02: Na declaração do método save passamos dois argumentos, com as seguintes funções:
○ @ModelAttribute: Realiza o bind entre o objeto de domínio enviado pelo formulário e o objeto esperado no controller;
○ RequestAttributes: Este objeto serve para atribuir valores em uma ação de redirect que parte do controller.

Linha 03: O objeto dao salva o usuário recebido do formulário;

Linha 04: Método para atribuir os valores que serão enviados via redirect;

Linha 05: Realiza um redirecionamento para o path /usuario/todos.


_EDITANDO REGISTROS 
Para a edição de registros, assim como para as demais ações na camada de visão, vamos criar um controller. Preparamos um controller que vai receber uma solicitação para atualização de registros a partir de um formulário.
Antes de realizar a edição de dados em um formulário no lado cliente, é necessário enviar ao formulário os dados que serão editados. Para isso, temos o seguinte método no controller:

01 @GetMapping("/update/")
02 public ModelAndView preUpdate(@PathVariable("id") Long id, ModelMap model) {
03   Usuario usuario = dao.getId(id);
04   model.addAttribute("usuario", usuario);
05   return new ModelAndView("/user/add", model);
06 }
Linha 01: Esta anotação mapeia uma solicitação enviada para o path /update/id;

Linha 02: @PathVariable captura na URL da solicitação o valor correspondente a seu parâmetro, neste caso, o valor referente ao id enviado na solicitação;

Linha 03: A partir do id recuperado na URL fazemos a consulta no dao pelo usuário que será editado;

Linha 04: Adicionamos na resposta da solicitação o usuário retornado pelo dao;

Linha 05: Como resposta à solicitação, a página do formulário será aberta com os dados do usuário que são entregues a ela pelo objeto model.



_EXCLUINDO ITENS DA LISTAGEM
Abaixo temos a implementação da controller em Spring MVC para receber como solicitação o pedido de exclusão de um usuário cadastrado na base.

Em uma classe do tipo controller há diversos métodos que recebem requisições do lado cliente da aplicação. 
Entre esses métodos, temos o responsável por receber o pedido de exclusão de um objeto de domínio, como pode ser visto a seguir:

01 @GetMapping("/delete/")
02 public String delete(@PathVariable("id") Long id, RedirectAttributes attr) {
03  dao.excluir(id);
04  attr.addFlashAttribute("message", "Usuário excluído com sucesso.");
05  return "redirect:/usuario/todos";
06 }

O método apresentado realiza a operação de exclusão de um registro via identificador recebido como parâmetro na URL da solicitação. 
Como resposta, realiza um redirecionamento, contendo uma mensagem de sucesso que vai ser exibida na página de resposta.



_CONVERSÃO DE DATAS 

A conversão de dados é uma necessidade cada vez mais comum, principalmente quando buscamos entregar para o usuário mais facilidades. 
Pensando nisso, o Spring MVC também nos traz recursos que simplificam esse trabalho. 
Saiba, neste vídeo, como converter uma data, enviada por um formulário no formato texto, em um objeto Java que representa um tipo data (Date, Calendar ou LocalDate), e também, veja como formatar uma data para ser exibida na página web.

Para converter uma data enviada por um formulário em um tipo Date, Calendar ou LocalDate, o Spring MVC possui um conversor padrão, baseado na anotação @DateTimeFormat.

Para fazer uso desse recurso, basta adicionar a anotação na classe de domínio, junto ao atributo do tipo data que se deseja converter.
Para confirmar como é simples fazer essa conversão, observe o código necessário a seguir:

@DateTimeFormat
private LocalDate dtNascimento;



_CONVERSÃO DE ENUM ENTRE VIEW E CONTROLLER

O Spring MVC nos fornece mais de uma opção para conversão de dados. 
Convertemos um valor do tipo texto, enviado a partir do formulário, em um objeto Java do tipo enum, utilizando os recursos do framework para automatizar essa mudança no tipo de dados.

Para converter um valor enviado por um formulário em um objeto Java complexo, que deve ser recebido em um controller, o processo é um pouco mais complexo do que o visto na aula anterior. É necessário habilitar a conversão na configuração do Spring MVC. Para isso, podemos implementar o método addFormatters(), como exposto abaixo:

01 @Override
02 public void addFormatters(FormatterRegistry registry) {
03  registry.addConverter(new TipoSexoConverter());
04 }
Esse método é herdado e sobrescrito da classe WebMvcConfigurerAdapter. O argumento registry fornece acesso ao método addConverter(), no qual se deve adicionar como parâmetro a instância da classe que contém o conversor de tipos. Esse conversor deve implementar a classe Converter, do pacote org.springframework.core.convert.converter.




_VALIDAÇÃO COM BEAN VALIDATION 

A validação de dados é um passo importante para a segurança e correto funcionamento da aplicação. Com o Spring MVC esse processo é facilitado devido ao suporte à Bean Validation. Aqui, será demonstrado como realizar a validação, no back-end, de dados enviados a partir de um formulário e também, como exibir as mensagens de validação na página.
O sistema de validação de formulários pelo lado servidor, em aplicações com Spring MVC, pode ser realizado com Bean Validation. Para isso, primeiro é necessário adicionar uma biblioteca que implementa a Bean Validation, como o Hibernate-Validator. Um exemplo, usando o gerenciador de dependências Maven, pode ser visualizado a seguir:

<dependency>
   <groupId>org.hibernate</groupId>
   <artifactId>hibernate-validator</artifactId>
   <version>5.3.2.Final</version>
</dependency>


Dessa forma, você terá acesso, nas classe de domínio, às anotações de validação - tanto aquelas que seguem a especificação Bean Validation, quanto as da implementação Hibernate-Validator.


_MENSAGENS DE VALIDAÇÃO VIA ARQUIVOS 
Para reduzir o acoplamento entre seu código e as mensagens de validação, é recomendado, muitas vezes, separar as mensagens de validação em um arquivo de propriedades.

Mensagens de validação podem ser adicionadas nas próprias anotações ou então, de forma considerada mais profissional, em um arquivo de propriedades.
Desse modo, se tem uma maior facilidade para atualização ou mesmo internacionalização das mensagens.

No Spring MVC, para carregar as mensagens de um arquivo de propriedades, é necessário criar um bean que diga ao Spring que ele deve carregar o arquivo, e este, por sua vez, deve estar no diretório “resources” no classpath da aplicação.

O bean apresentado a seguir é um exemplo. Em seu código, o método setBasename() recebe como valor o nome do arquivo de propriedades, sem a extensão “.properties”.

01 @Bean
02 public MessageSource messageSource() {
03   ResourceBundleMessageSource source = new ResourceBundleMessageSource();
04   source.setBasename("messages");
05   return source;
06 }




_INSERINDO O BOOTSTRAP 
Como exemplo, vamos usar o framework Bootstrap e seu arquivo “bootstrap.css” para apresentar a técnica que deve ser adotada nestas situações.
Em aplicações web é muito comum trabalhar com arquivos estáticos no front-end. CSS, JS e JPEG são exemplos de arquivos considerados estáticos.
Para fazer uso desses arquivos no Spring MVC é preciso habilitar essa funcionalidade a partir de um método herdado da classe WebMvcConfigurerAdapter, como exposto a seguir:

01 @Override
02 public void addResourceHandlers(ResourceHandlerRegistry registry) {
03  registry.addResourceHandler("/static/**")
04     .addResourceLocations("/WEB-INF/resources/");
05 }
O método addResourceHandlers() deve ser sobrescrito com informações sobre o local onde os arquivos estáticos se encontram;

Linha 03: O método addResourceHandler() recebe uma instrução que vai trabalhar como um atalho dentro da página JSP para alcançar o arquivo que deve ser carregado;

Linha 04: O método addResourceLocations() deve receber como parâmetro o local raiz de onde os arquivos estáticos estão localizados. Normalmente esse local é o diretório WEB-INF/resources.






RODANDO O SISTEMA

VOCÊ PRECISA BAIXAR O SERVIDOR WILDFLY ( ÀS VEZES DENOMINADO JBOSS)
deve configurá-lo e inserir o seu projeto dentro desse container para que ele seja executado. 






















